{"entries":[{"timestamp":1744230357145,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"function drawTurtle(cmds: number[][]) {\r\n    bluetooth.uartWriteString(\"%dsta\")\r\n    console.log(\"drawing\" + cmds)\r\n    for (let i = 0; i < cmds.length; i++) {\r\n        bluetooth.uartWriteString(\"%dr\" + i)\r\n        console.log(cmds[i])\r\n        if (cmds[i][0] == 1) {\r\n            //forwards\r\n            vanGogh.fd(cmds[i][1])\r\n        } else if (cmds[i][0] == 2) {\r\n            //left\r\n            vanGogh.re(cmds[i][1], false)\r\n        } else if (cmds[i][0] == 3) {\r\n            //right"],[1,"//% color=\"#EE6A50\" icon=\"\\uf013\" block=\"Magic:bit PCAmotor\" blockId=\"PCAmotor\"\r\nnamespace PCAmotor {\r\n    const PCA9685_ADDRESS = 0x40\r\n    const MODE1 = 0x00\r\n    const MODE2 = 0x01\r\n    const SUBADR1 = 0x02\r\n    const SUBADR2 = 0x03\r\n    const SUBADR3 = 0x04\r\n    const PRESCALE = 0xFE\r\n    const LED0_ON_L = 0x06\r\n    const LED0_ON_H = 0x07\r\n    const LED0_OFF_L = 0x08\r\n    const LED0_OFF_H = 0x09\r\n    const ALL_LED_ON_L = 0xFA\r\n    const ALL_LED_ON_H = 0xFB\r\n    const ALL_LED_OFF_L = 0xFC\r\n    const ALL_LED_OFF_H = 0xFD\r\n\r\n    const STP_CHA_L = 2047\r\n    const STP_CHA_H = 4095\r\n\r\n    const STP_CHB_L = 1\r\n    const STP_CHB_H = 2047\r\n\r\n    const STP_CHC_L = 1023\r\n    const STP_CHC_H = 3071\r\n\r\n    const STP_CHD_L = 3071\r\n    const STP_CHD_H = 1023\r\n\r\n    export enum Motors {\r\n        //% block=\"M1\"\r\n        M1 = 0x3,\r\n        //% block=\"M2\"\r\n        M2 = 0x4,\r\n        //% block=\"M3\"\r\n        M3 = 0x1,\r\n        //% block=\"M4\"\r\n        M4 = 0x2\r\n    }\r\n\r\n    export enum Steppers {\r\n        //% block=\"STPM1\"\r\n        STPM1 = 0x1,\r\n        //% block=\"STPM2\"\r\n        STPM2 = 0x2\r\n    }\r\n\r\n    export enum Servos {\r\n        //% block=\"S1\"\r\n        S1 = 0x01,\r\n        //% block=\"S2\"\r\n        S2 = 0x02,\r\n        //% block=\"S3\"\r\n        S3 = 0x03,\r\n        //% block=\"S4\"\r\n        S4 = 0x04,\r\n        //% block=\"S5\"\r\n        S5 = 0x05,\r\n        //% block=\"S6\"\r\n        S6 = 0x06,\r\n        //% block=\"S7\"\r\n        S7 = 0x07,\r\n        //% block=\"S8\"\r\n        S8 = 0x08\r\n    }\r\n\r\n    let initialized = false\r\n\r\n    function i2cwrite(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2ccmd(addr: number, value: number) {\r\n        let buf = pins.createBuffer(1)\r\n        buf[0] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    function initPCA9685(): void {\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\r\n        setFreq(50);\r\n        for (let idx = 0; idx < 16; idx++) {\r\n            setPwm(idx, 0, 0);"],[0,"\r\n  "]],"start1":0,"start2":0,"length1":493,"length2":2282},{"diffs":[[0,"    "],[1,"}\r\n"],[0,"    "],[-1,"vanGogh.re(cmds[i][1], true)\r\n        } else if (cmds[i][0] == 4) {\r\n            vanGogh.penDown()\r\n        } else if (cmds[i][0] == 5) {\r\n            //penup\r\n            vanGogh.penUp()\r\n        }"],[1,"    initialized = true\r\n    }\r\n\r\n    function setFreq(freq: number): void {\r\n        // Constrain the frequency\r\n        let prescaleval = 25000000;\r\n        prescaleval /= 4096;\r\n        prescaleval /= freq;\r\n        prescaleval -= 1;\r\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\r\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\r\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\r\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\r\n        control.waitMicros(5000);\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);"],[0,"\r\n  "]],"start1":2284,"start2":2284,"length1":210,"length2":723},{"diffs":[[0," }\r\n"],[1,"\r\n"],[0,"    "],[-1,"vanGogh.penUp()\r\n    bluetooth.uartWriteString(\"%dend\""],[1,"function setPwm(channel: number, on: number, off: number): void {\r\n        if (channel < 0 || channel > 15)\r\n            return;\r\n        //serial.writeValue(\"ch\", channel)\r\n        //serial.writeValue(\"on\", on)\r\n        //serial.writeValue(\"off\", off"],[0,")\r\n"],[-1,"}"],[0,"\r\n"],[-1,"let cmds: number[][] = [[3]]\r\nvanGogh.penDown()\r\nvanGogh.penUp()\r\nbluetooth.startUartService();\r\nconsole.log(\"started\");\r\n\r\n\r\nfunction stringToNumberMatrix(input: string): number[][] {\r\n    const matrix: number[][] = [];\r\n    // Split the string by the substring \"],[\"\r\n    const rows = input.split(\"],[\");\r\n    for (let row of rows) {\r\n        row = row.trim();\r\n        // Remove any leading '[' from the first chunk\r\n        if (row[0] === \"[\") {\r\n            row = row.slice(1, row.length);\r\n        }\r\n        // Remove any trailing ']' from the last chunk\r\n        if (row[row.length - 1] === \"]\") {\r\n            row = row.slice(0, row.length - 1);\r\n        }"],[1,"        let buf = pins.createBuffer(5);\r\n        buf[0] = LED0_ON_L + 4 * channel;\r\n        buf[1] = on & 0xff;\r\n        buf[2] = (on >> 8) & 0xff;\r\n        buf[3] = off & 0xff;\r\n        buf[4] = (off >> 8) & 0xff;\r\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\r\n    }\r\n\r\n    function setStepper(index: number, dir: boolean): void {\r\n        if (index == 1) {\r\n            if (dir) {\r\n                setPwm(0, STP_CHA_L, STP_CHA_H);\r\n                setPwm(2, STP_CHB_L, STP_CHB_H);\r\n                setPwm(1, STP_CHC_L, STP_CHC_H);\r\n                setPwm(3, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(3, STP_CHA_L, STP_CHA_H);\r\n                setPwm(1, STP_CHB_L, STP_CHB_H);\r\n                setPwm(2, STP_CHC_L, STP_CHC_H);\r\n                setPwm(0, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        } else {\r\n            if (dir) {\r\n                setPwm(4, STP_CHA_L, STP_CHA_H);\r\n                setPwm(6, STP_CHB_L, STP_CHB_H);\r\n                setPwm(5, STP_CHC_L, STP_CHC_H);\r\n                setPwm(7, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(7, STP_CHA_L, STP_CHA_H);\r\n                setPwm(5, STP_CHB_L, STP_CHB_H);\r\n                setPwm(6, STP_CHC_L, STP_CHC_H);\r\n                setPwm(4, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        }\r\n    }\r\n\r\n    function stopMotor(index: number) {\r\n        setPwm((index - 1) * 2, 0, 0);\r\n        setPwm((index - 1) * 2 + 1, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Stepper run\r\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\r\n     * @param dir is forward direction; eg: true\r\n    */\r\n    //% blockId=magicbit_stepper_start block=\"Stepper 28BYJ-48|%index|start\"\r\n    //% weight=92\r\n    export function StepperStart(index: Steppers, dir: boolean = true): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(index, dir);\r\n    }\r\n\r\n    /**\r\n     * Stepper stop\r\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\r\n    */\r\n    //% blockId=magicbit_stepper_stop block=\"Stepper 28BYJ-48|%index|stop\"\r\n    //% weight=93\r\n    export function StepperStop(index: Steppers): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        for (let i = 4; i > 0; i--) {\r\n            setPwm(index * 4 - i, 0, 0);\r\n        }\r\n    }\r\n\r\n    //% blockId=magicbit_stepper_degree block=\"Stepper 28BYJ-48|%index|degree %degree\"\r\n    //% weight=90\r\n    export function StepperDegree(index: Steppers, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(index, degree > 0);\r\n        degree = Math.abs(degree);\r\n        basic.pause(10240 * degree / 360);\r\n        //StopMotor\r\n        for (let i = 3; i <= 0; i--) {\r\n            setPwm(index * 4 - i, 0, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stepper Car move forward\r\n     * @param distance Distance to move in cm; eg: 10, 20\r\n     * @param diameter diameter of wheel in mm; eg: 48\r\n    */\r\n    //% blockId=magicbit_stpcar_move block=\"Car Forward|Distance(cm) %distance|Wheel Diameter(mm) %diameter\"\r\n    //% weight=88\r\n    export function StpCarMove(distance: number, diameter: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        let delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\r\n        setStepper(1, delay > 0);\r\n        setStepper(2, delay > 0);\r\n        delay = Math.abs(delay);\r\n        basic.pause(delay);\r\n        MotorStopAll()\r\n    }\r\n\r\n    /**\r\n     * DC motor run\r\n     * @param index Index of motor; eg: PCAmotor.Motors.M1\r\n     * @param speed relative speed from -255 to 255; eg: 200"],[0,"\r\n    "],[1,"*/\r\n"],[0,"    //"],[-1," Split by comma and convert to numbers\r\n        const numbers = row\r\n            .split(\",\")\r\n            .map((value) => parseFloat(value.trim()))\r\n            .filter((num) => !isNaN(num));\r\n        matrix.push(numbers);"],[1,"% blockId=magicbit_motor_run block=\"Motor|%index|speed %speed\"\r\n    //% weight=85\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRun(index: Motors, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        speed = speed * 16; // map 255 to 4096\r\n        if (speed >= 4096) {\r\n            speed = 4095\r\n        }\r\n        if (speed <= -4096) {\r\n            speed = -4095\r\n        }\r\n        if (index > 4 || index <= 0)\r\n            return\r\n        let pp = (index - 1) * 2\r\n        let pn = (index - 1) * 2 + 1\r\n        if (speed >= 0) {\r\n            setPwm(pp, 0, speed)\r\n            setPwm(pn, 0, 0)\r\n        } else {\r\n            setPwm(pp, 0, 0)\r\n            setPwm(pn, 0, -speed)\r\n        }\r\n    }\r\n\r\n    //% blockId=magicbit_stop block=\"Motor Stop|%index|\"\r\n    //% weight=80\r\n    export function MotorStop(index: Motors): void {"],[0,"\r\n    "],[-1,"}\r\n"],[0,"    "],[-1,"return matrix;\r\n}\r\n\r\nlet receivedData = \"\";\r\n\r\nbluetooth.onUartDataReceived(serial.delimiters(Delimiters.NewLine), function () {\r\n    const received = bluetooth.uartReadUntil(serial.delimiters(Delimiters.NewLine));\r\n    //console.log(\"Received: \" + received);\r\n    if (received === \"#\") {\r\n        console.log(\"received all data\");"],[1,"MotorRun(index, 0);\r\n    }\r\n\r\n    //% blockId=magicbit_stop_all block=\"Motor Stop All\"\r\n    //% weight=79\r\n    //% blockGap=50\r\n    export function MotorStopAll(): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        for (let idx = 1; idx <= 4; idx++) {\r\n            stopMotor(idx);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Servo Execute\r\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\r\n    */\r\n    //% blockId=magicbit_servo block=\"Servo|%index|degree %degree\"\r\n    //% weight=100\r\n    //% degree.min=0 degree.max=180\r\n    export function Servo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n\r\n    /**\r\n      * Servo Execute (from-to)\r\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n      * @param degree1 [0-180] degree of servo; eg: 0, 90, 180\r\n      * @param degree2 [0-180] degree of servo; eg: 0, 90, 180\r\n      * @param speed [1-10] speed of servo; eg: 1, 10\r\n     */\r\n    //% blockId=motorbit_servospeed block=\"Servo|%index|degree start %degree1|end %degree2|speed %speed\"\r\n    //% weight=98\r\n    //% degree1.min=0 degree1.max=180\r\n    //% degree2.min=0 degree2.max=180\r\n    //% speed.min=1 speed.max=10\r\n    //% inlineInputMode=inline\r\n    export function Servospeed(index: Servos, degree1: number, degree2: number, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        if (degree1 > degree2) {\r\n            for (let i = degree1; i > degree2; i--) {\r\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n                let value = v_us * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }\r\n        }\r\n        else {\r\n            for (let i = degree1; i < degree2; i++) {\r\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n                let value = v_us * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }"],[0,"\r\n  "]],"start1":3008,"start2":3008,"length1":1315,"length2":7193},{"diffs":[[0,"    "],[-1,"cmds = stringToNumberMatrix(receivedData);\r\n        drawTurtle(cmds);\r\n        receivedData = \"\";\r\n    } else {\r\n        receivedData += received;"],[1,"}\r\n    }\r\n\r\n    /**\r\n     * Geek Servo Execute\r\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n     * @param pwm pulse width [500-2500] in ms of servo; eg: 500, 1500, 2500\r\n    */\r\n    //% blockId=magicbit_geekservo block=\"Servo|%index|pulse width %v_us\"\r\n    //% weight=90\r\n    //% v_us.min=300 v_us.max=2800\r\n    export function GeekServo(index: Servos, v_us: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let value = Math.constrain(v_us, 300, 2800) * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n\r\n    /**\r\n      * Geek Servo Execute (from-to)\r\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n      * @param pwm1 [300-2800];\r\n      * @param pwm2 [300-2800];\r\n      * @param speed [1-10] speed of servo; eg: 1, 10\r\n     */\r\n    //% blockId=motorbit_gsrvspeed block=\"Servo|%index|pulse start %pwm1|end %pwm2|speed %speed\""],[0,"\r\n    "],[-1,"}\r\n})\r\n\r\nbluetooth.onBluetoothConnected(function () {\r\n    music.playTone(Note.A4, 100)\r\n})\r\nbluetooth.onBluetoothDisconnected(function ()"],[1,"//% weight=87\r\n    //% pwm1.min=400 pwm1.max=2600\r\n    //% pwm2.min=400 pwm2.max=2600\r\n    //% speed.min=1 speed.max=10\r\n    //% inlineInputMode=inline\r\n    export function GeekServospeed(index: Servos, pwm1: number, pwm2: number, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        pwm1 = Math.round(pwm1 / 10) * 10\r\n        pwm2 = Math.round(pwm2 / 10) * 10\r\n        // 50hz: 20,000 us\r\n        if (pwm1 > pwm2) {\r\n            for (let i = pwm1; i >= pwm2; i -= 10) {\r\n                let value = i * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }\r\n        }\r\n        else {\r\n            for (let i = pwm1; i <= pwm2; i += 10) {\r\n                let value = i * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release servo\r\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n    */\r\n    //% blockId=magicbit_stopservo block=\"Servo|%index|\"\r\n    //% weight=80\r\n    export function StopServo(index: Servos): void"],[0," {\r\n    "],[-1,"music.playTone(Note.C3, 100)\r\n})"],[1,"    if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setPwm(index + 7, 0, 0)\r\n    }\r\n}"]],"start1":10203,"start2":10203,"length1":334,"length2":2207}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"pxt-vangogh-painter"],[1,"motors"],[0,"\",\n "]],"start1":11,"start2":11,"length1":27,"length2":14},{"diffs":[[0,"   \""],[-1,"microphone"],[1,"radio"],[0,"\": \""]],"start1":95,"start2":95,"length1":18,"length2":13},{"diffs":[[0,"   \""],[-1,"bluetooth\": \"*\",\n        \"pxt-magicbit-pca9685\": \"github:microbit-cz/pxt-magicbit-pca9685#1e097c914b2c7ed1f4071d7b6288ef64812030e2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"motors.ts\",\n        \"vangogh.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"yotta\": {\n        \"config\": {\n            \"microbit-dal\": {\n                \"bluetooth\": {\n                    \"open\": 1,\n                    \"whitelist\": 0,\n                    \"security_level\": null\n                }\n            }\n        }\n    }"],[1,"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":117,"start2":117,"length1":558,"length2":144}]},{"type":"added","filename":"motors.ts","value":"//% color=\"#EE6A50\" icon=\"\\uf013\" block=\"Magic:bit PCAmotor\" blockId=\"PCAmotor\"\nnamespace PCAmotor {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const STP_CHA_L = 2047\n    const STP_CHA_H = 4095\n\n    const STP_CHB_L = 1\n    const STP_CHB_H = 2047\n\n    const STP_CHC_L = 1023\n    const STP_CHC_H = 3071\n\n    const STP_CHD_L = 3071\n    const STP_CHD_H = 1023\n\n    export enum Motors {\n        //% block=\"M1\"\n        M1 = 0x3,\n        //% block=\"M2\"\n        M2 = 0x4,\n        //% block=\"M3\"\n        M3 = 0x1,\n        //% block=\"M4\"\n        M4 = 0x2\n    }\n\n    export enum Steppers {\n        //% block=\"STPM1\"\n        STPM1 = 0x1,\n        //% block=\"STPM2\"\n        STPM2 = 0x2\n    }\n\n    export enum Servos {\n        //% block=\"S1\"\n        S1 = 0x01,\n        //% block=\"S2\"\n        S2 = 0x02,\n        //% block=\"S3\"\n        S3 = 0x03,\n        //% block=\"S4\"\n        S4 = 0x04,\n        //% block=\"S5\"\n        S5 = 0x05,\n        //% block=\"S6\"\n        S6 = 0x06,\n        //% block=\"S7\"\n        S7 = 0x07,\n        //% block=\"S8\"\n        S8 = 0x08\n    }\n\n    let initialized = false\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1)\n        buf[0] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n            setPwm(idx, 0, 0);\n        }\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        //serial.writeValue(\"ch\", channel)\n        //serial.writeValue(\"on\", on)\n        //serial.writeValue(\"off\", off)\n\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n    function setStepper(index: number, dir: boolean): void {\n        if (index == 1) {\n            if (dir) {\n                setPwm(0, STP_CHA_L, STP_CHA_H);\n                setPwm(2, STP_CHB_L, STP_CHB_H);\n                setPwm(1, STP_CHC_L, STP_CHC_H);\n                setPwm(3, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(3, STP_CHA_L, STP_CHA_H);\n                setPwm(1, STP_CHB_L, STP_CHB_H);\n                setPwm(2, STP_CHC_L, STP_CHC_H);\n                setPwm(0, STP_CHD_L, STP_CHD_H);\n            }\n        } else {\n            if (dir) {\n                setPwm(4, STP_CHA_L, STP_CHA_H);\n                setPwm(6, STP_CHB_L, STP_CHB_H);\n                setPwm(5, STP_CHC_L, STP_CHC_H);\n                setPwm(7, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(7, STP_CHA_L, STP_CHA_H);\n                setPwm(5, STP_CHB_L, STP_CHB_H);\n                setPwm(6, STP_CHC_L, STP_CHC_H);\n                setPwm(4, STP_CHD_L, STP_CHD_H);\n            }\n        }\n    }\n\n    function stopMotor(index: number) {\n        setPwm((index - 1) * 2, 0, 0);\n        setPwm((index - 1) * 2 + 1, 0, 0);\n    }\n\n    /**\n     * Stepper run\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\n     * @param dir is forward direction; eg: true\n    */\n    //% blockId=magicbit_stepper_start block=\"Stepper 28BYJ-48|%index|start\"\n    //% weight=92\n    export function StepperStart(index: Steppers, dir: boolean = true): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(index, dir);\n    }\n\n    /**\n     * Stepper stop\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\n    */\n    //% blockId=magicbit_stepper_stop block=\"Stepper 28BYJ-48|%index|stop\"\n    //% weight=93\n    export function StepperStop(index: Steppers): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        for (let i = 4; i > 0; i--) {\n            setPwm(index * 4 - i, 0, 0);\n        }\n    }\n\n    //% blockId=magicbit_stepper_degree block=\"Stepper 28BYJ-48|%index|degree %degree\"\n    //% weight=90\n    export function StepperDegree(index: Steppers, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(index, degree > 0);\n        degree = Math.abs(degree);\n        basic.pause(10240 * degree / 360);\n        //StopMotor\n        for (let i = 3; i <= 0; i--) {\n            setPwm(index * 4 - i, 0, 0);\n        }\n    }\n\n    /**\n     * Stepper Car move forward\n     * @param distance Distance to move in cm; eg: 10, 20\n     * @param diameter diameter of wheel in mm; eg: 48\n    */\n    //% blockId=magicbit_stpcar_move block=\"Car Forward|Distance(cm) %distance|Wheel Diameter(mm) %diameter\"\n    //% weight=88\n    export function StpCarMove(distance: number, diameter: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        let delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\n        setStepper(1, delay > 0);\n        setStepper(2, delay > 0);\n        delay = Math.abs(delay);\n        basic.pause(delay);\n        MotorStopAll()\n    }\n\n    /**\n     * DC motor run\n     * @param index Index of motor; eg: PCAmotor.Motors.M1\n     * @param speed relative speed from -255 to 255; eg: 200\n    */\n    //% blockId=magicbit_motor_run block=\"Motor|%index|speed %speed\"\n    //% weight=85\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRun(index: Motors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 4 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        if (speed >= 0) {\n            setPwm(pp, 0, speed)\n            setPwm(pn, 0, 0)\n        } else {\n            setPwm(pp, 0, 0)\n            setPwm(pn, 0, -speed)\n        }\n    }\n\n    //% blockId=magicbit_stop block=\"Motor Stop|%index|\"\n    //% weight=80\n    export function MotorStop(index: Motors): void {\n        MotorRun(index, 0);\n    }\n\n    //% blockId=magicbit_stop_all block=\"Motor Stop All\"\n    //% weight=79\n    //% blockGap=50\n    export function MotorStopAll(): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        for (let idx = 1; idx <= 4; idx++) {\n            stopMotor(idx);\n        }\n    }\n\n    /**\n     * Servo Execute\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\n    */\n    //% blockId=magicbit_servo block=\"Servo|%index|degree %degree\"\n    //% weight=100\n    //% degree.min=0 degree.max=180\n    export function Servo(index: Servos, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\n        let value = v_us * 4096 / 20000\n        setPwm(index + 7, 0, value)\n    }\n\n    /**\n      * Servo Execute (from-to)\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\n      * @param degree1 [0-180] degree of servo; eg: 0, 90, 180\n      * @param degree2 [0-180] degree of servo; eg: 0, 90, 180\n      * @param speed [1-10] speed of servo; eg: 1, 10\n     */\n    //% blockId=motorbit_servospeed block=\"Servo|%index|degree start %degree1|end %degree2|speed %speed\"\n    //% weight=98\n    //% degree1.min=0 degree1.max=180\n    //% degree2.min=0 degree2.max=180\n    //% speed.min=1 speed.max=10\n    //% inlineInputMode=inline\n    export function Servospeed(index: Servos, degree1: number, degree2: number, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        if (degree1 > degree2) {\n            for (let i = degree1; i > degree2; i--) {\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\n                let value = v_us * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n        else {\n            for (let i = degree1; i < degree2; i++) {\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\n                let value = v_us * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n    }\n\n    /**\n     * Geek Servo Execute\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\n     * @param pwm pulse width [500-2500] in ms of servo; eg: 500, 1500, 2500\n    */\n    //% blockId=magicbit_geekservo block=\"Servo|%index|pulse width %v_us\"\n    //% weight=90\n    //% v_us.min=300 v_us.max=2800\n    export function GeekServo(index: Servos, v_us: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let value = Math.constrain(v_us, 300, 2800) * 4096 / 20000\n        setPwm(index + 7, 0, value)\n    }\n\n    /**\n      * Geek Servo Execute (from-to)\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\n      * @param pwm1 [300-2800];\n      * @param pwm2 [300-2800];\n      * @param speed [1-10] speed of servo; eg: 1, 10\n     */\n    //% blockId=motorbit_gsrvspeed block=\"Servo|%index|pulse start %pwm1|end %pwm2|speed %speed\"\n    //% weight=87\n    //% pwm1.min=400 pwm1.max=2600\n    //% pwm2.min=400 pwm2.max=2600\n    //% speed.min=1 speed.max=10\n    //% inlineInputMode=inline\n    export function GeekServospeed(index: Servos, pwm1: number, pwm2: number, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        pwm1 = Math.round(pwm1 / 10) * 10\n        pwm2 = Math.round(pwm2 / 10) * 10\n        // 50hz: 20,000 us\n        if (pwm1 > pwm2) {\n            for (let i = pwm1; i >= pwm2; i -= 10) {\n                let value = i * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n        else {\n            for (let i = pwm1; i <= pwm2; i += 10) {\n                let value = i * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n    }\n\n    /**\n     * Release servo\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\n    */\n    //% blockId=magicbit_stopservo block=\"Servo|%index|\"\n    //% weight=80\n    export function StopServo(index: Servos): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setPwm(index + 7, 0, 0)\n    }\n}"},{"type":"added","filename":"vangogh.ts","value":"//% color=\"#CC7722\" icon=\"/f1fc\" block=\"Van Gogh\" blockId=\"vanGogh\"\nnamespace vanGogh {\n    // initialization of servos\n    const _pen = PCAmotor.Servos.S1;\n    const _left = PCAmotor.Steppers.STPM1;\n    const _right = PCAmotor.Steppers.STPM2;\n    // How much does the pen lower or raise\n    const _minPenHeight = 1900;\n    const _maxPenHeight = 1260;\n    //shift speed in mm/ms\n    const _spd = 0.0215;\n    //rotation speed deg/ms\n    const _degSpd = 0.0178;\n\n    // Always start calibration with Distance Calibration then Rotation Calibration\n\n    //% blockId=calibDist block=\"Calibrate distance\"\n    //% weight=79\n    //% blockGap=50\n    export function calibDist() {\n        penUp();\n        basic.pause(500);\n        PCAmotor.StepperStart(_left);\n        PCAmotor.StepperStart(_right);\n        basic.pause(500);\n        PCAmotor.MotorStopAll();\n        penDown();\n        basic.pause(500);\n        PCAmotor.StepperStart(_left);\n        PCAmotor.StepperStart(_right);\n        basic.pause(5000);\n        PCAmotor.MotorStopAll();\n        penUp();\n    }\n\n    //% blockId=calibRot block=\"Calibrate rotation\"\n    //% weight=79\n    //% blockGap=50\n    export function calibRot() {\n        penDown();\n        fd(50);\n        penUp();\n        fd(50, false);\n        penDown();\n        PCAmotor.StepperStart(_left, false);\n        PCAmotor.StepperStart(_right);\n        basic.pause(5000);\n        PCAmotor.MotorStopAll();\n        fd(50);\n        penUp();\n        fd(50, false);\n    }\n\n    /**\n     * Van Gogh move\n     * @param dist is distance of run in mm; eg: 10\n     * @param invert is direction forward or backward; eg: true\n    */\n    //% blockId=fd block=\"Van Gogh move |%dist| mm forward |%invert|\"\n    //% weight=92\n    export function fd(dist: number, invert: boolean = true): void {\n        PCAmotor.StepperStart(_left, invert);\n        PCAmotor.StepperStart(_right, invert);\n        basic.pause(calcDist(dist));\n        PCAmotor.MotorStopAll();\n    }\n\n    /**\n     * Van Gogh move with certain speed\n     * @param dist is distance of run in mm; eg: 10\n     * @param interval is indicates the frequency of stopping in ms; eg: 10\n     * @param invert is direction forward or backward; eg: true\n    */\n    //% blockId=fdSpeed block=\"Van Gogh move |%dist| mm forward |%invert| with stopping |%interval|\"\n    //% weight=92\n    export function fdSpeed(dist: number, invert: boolean = true, interval: number = 1000): void {\n        for (let i = 0; i <= interval; i++) {\n            fd(dist / interval, invert);\n            PCAmotor.MotorStopAll();\n            basic.pause(1);\n        }\n    }\n\n    /**\n     * Van Gogh rotate\n     * @param deg is rotation in degrees; eg: 10\n     * @param invert is direction of rotation; eg: true\n    */\n    //% blockId=re block=\"Van Gogh rotate |%deg|° clockwise |%invert|\"\n    //% weight=92\n    export function re(deg: number, invert: boolean = true): void {\n        PCAmotor.StepperStart(_left, invert);\n        PCAmotor.StepperStart(_right, !invert);\n        basic.pause(calcDeg(deg));\n        PCAmotor.MotorStopAll();\n    }\n\n    // Calculate distance to time with calibrated run speed\n    function calcDist(t: number): number {\n        return t / _spd;\n    }\n    // VCalculate rotation to time with calibrated rotation speed\n    function calcDeg(d: number): number {\n        return d / _degSpd;\n    }\n\n    //% blockId=penUp block=\"Raise pen\"\n    //% weight=79\n    //% blockGap=50\n    export function penUp(): void {\n        PCAmotor.GeekServo(_pen, _minPenHeight);\n        basic.showArrow(ArrowNames.North);\n    }\n\n    //% blockId=penDown block=\"Launch pen\"\n    //% weight=79\n    //% blockGap=50\n    export function penDown(): void {\n        PCAmotor.GeekServo(_pen, _maxPenHeight);\n        basic.showArrow(ArrowNames.South);\n    }\n\n    /**\n     * Van Gogh draw rectangle\n     * @param a is length of side A; eg: 10\n     * @param b is length of side B; eg: 10\n    */\n    //% blockId=rectangle block=\"Van Gogh draw rectangle of size |%a| mm side A and of size |%b| mm side B\"\n    //% weight=92\n    export function rectangle(a: number, b: number): void {\n        penDown();\n        for (let i = 0; i < 4; i++) {\n            re(90);\n            fd(i % 2 == 0 ? a : b);\n        }\n        penUp();\n    }\n\n    /**\n     * Van Gogh draw circle\n     * @param d is diameter of circle; eg: 10\n    */\n    //% blockId=circle block=\"Van Gogh draw circle with diameter of |%d| mm\"\n    //% weight=92\n    export function circle(d: number): void {\n        const circumference = Math.PI * d;\n        penUp();\n        fd(d / 2);\n        re(90);\n        for (let i = 0; i < 60; i++) {\n            penDown();\n            fd(circumference / 60);\n            re(6);\n        }\n        penUp();\n    }\n}"}]},{"timestamp":1744230927872,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ME.md\",\n"],[1,"        \"motors.ts\",\n"],[0,"        "]],"start1":348,"start2":348,"length1":16,"length2":37}]},{"type":"removed","filename":"motors.ts","value":"//% color=\"#EE6A50\" icon=\"\\uf013\" block=\"Magic:bit PCAmotor\" blockId=\"PCAmotor\"\nnamespace PCAmotor {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const STP_CHA_L = 2047\n    const STP_CHA_H = 4095\n\n    const STP_CHB_L = 1\n    const STP_CHB_H = 2047\n\n    const STP_CHC_L = 1023\n    const STP_CHC_H = 3071\n\n    const STP_CHD_L = 3071\n    const STP_CHD_H = 1023\n\n    export enum Motors {\n        //% block=\"M1\"\n        M1 = 0x3,\n        //% block=\"M2\"\n        M2 = 0x4,\n        //% block=\"M3\"\n        M3 = 0x1,\n        //% block=\"M4\"\n        M4 = 0x2\n    }\n\n    export enum Steppers {\n        //% block=\"STPM1\"\n        STPM1 = 0x1,\n        //% block=\"STPM2\"\n        STPM2 = 0x2\n    }\n\n    export enum Servos {\n        //% block=\"S1\"\n        S1 = 0x01,\n        //% block=\"S2\"\n        S2 = 0x02,\n        //% block=\"S3\"\n        S3 = 0x03,\n        //% block=\"S4\"\n        S4 = 0x04,\n        //% block=\"S5\"\n        S5 = 0x05,\n        //% block=\"S6\"\n        S6 = 0x06,\n        //% block=\"S7\"\n        S7 = 0x07,\n        //% block=\"S8\"\n        S8 = 0x08\n    }\n\n    let initialized = false\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1)\n        buf[0] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n            setPwm(idx, 0, 0);\n        }\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        //serial.writeValue(\"ch\", channel)\n        //serial.writeValue(\"on\", on)\n        //serial.writeValue(\"off\", off)\n\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n    function setStepper(index: number, dir: boolean): void {\n        if (index == 1) {\n            if (dir) {\n                setPwm(0, STP_CHA_L, STP_CHA_H);\n                setPwm(2, STP_CHB_L, STP_CHB_H);\n                setPwm(1, STP_CHC_L, STP_CHC_H);\n                setPwm(3, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(3, STP_CHA_L, STP_CHA_H);\n                setPwm(1, STP_CHB_L, STP_CHB_H);\n                setPwm(2, STP_CHC_L, STP_CHC_H);\n                setPwm(0, STP_CHD_L, STP_CHD_H);\n            }\n        } else {\n            if (dir) {\n                setPwm(4, STP_CHA_L, STP_CHA_H);\n                setPwm(6, STP_CHB_L, STP_CHB_H);\n                setPwm(5, STP_CHC_L, STP_CHC_H);\n                setPwm(7, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(7, STP_CHA_L, STP_CHA_H);\n                setPwm(5, STP_CHB_L, STP_CHB_H);\n                setPwm(6, STP_CHC_L, STP_CHC_H);\n                setPwm(4, STP_CHD_L, STP_CHD_H);\n            }\n        }\n    }\n\n    function stopMotor(index: number) {\n        setPwm((index - 1) * 2, 0, 0);\n        setPwm((index - 1) * 2 + 1, 0, 0);\n    }\n\n    /**\n     * Stepper run\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\n     * @param dir is forward direction; eg: true\n    */\n    //% blockId=magicbit_stepper_start block=\"Stepper 28BYJ-48|%index|start\"\n    //% weight=92\n    export function StepperStart(index: Steppers, dir: boolean = true): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(index, dir);\n    }\n\n    /**\n     * Stepper stop\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\n    */\n    //% blockId=magicbit_stepper_stop block=\"Stepper 28BYJ-48|%index|stop\"\n    //% weight=93\n    export function StepperStop(index: Steppers): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        for (let i = 4; i > 0; i--) {\n            setPwm(index * 4 - i, 0, 0);\n        }\n    }\n\n    //% blockId=magicbit_stepper_degree block=\"Stepper 28BYJ-48|%index|degree %degree\"\n    //% weight=90\n    export function StepperDegree(index: Steppers, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(index, degree > 0);\n        degree = Math.abs(degree);\n        basic.pause(10240 * degree / 360);\n        //StopMotor\n        for (let i = 3; i <= 0; i--) {\n            setPwm(index * 4 - i, 0, 0);\n        }\n    }\n\n    /**\n     * Stepper Car move forward\n     * @param distance Distance to move in cm; eg: 10, 20\n     * @param diameter diameter of wheel in mm; eg: 48\n    */\n    //% blockId=magicbit_stpcar_move block=\"Car Forward|Distance(cm) %distance|Wheel Diameter(mm) %diameter\"\n    //% weight=88\n    export function StpCarMove(distance: number, diameter: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        let delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\n        setStepper(1, delay > 0);\n        setStepper(2, delay > 0);\n        delay = Math.abs(delay);\n        basic.pause(delay);\n        MotorStopAll()\n    }\n\n    /**\n     * DC motor run\n     * @param index Index of motor; eg: PCAmotor.Motors.M1\n     * @param speed relative speed from -255 to 255; eg: 200\n    */\n    //% blockId=magicbit_motor_run block=\"Motor|%index|speed %speed\"\n    //% weight=85\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRun(index: Motors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 4 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        if (speed >= 0) {\n            setPwm(pp, 0, speed)\n            setPwm(pn, 0, 0)\n        } else {\n            setPwm(pp, 0, 0)\n            setPwm(pn, 0, -speed)\n        }\n    }\n\n    //% blockId=magicbit_stop block=\"Motor Stop|%index|\"\n    //% weight=80\n    export function MotorStop(index: Motors): void {\n        MotorRun(index, 0);\n    }\n\n    //% blockId=magicbit_stop_all block=\"Motor Stop All\"\n    //% weight=79\n    //% blockGap=50\n    export function MotorStopAll(): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        for (let idx = 1; idx <= 4; idx++) {\n            stopMotor(idx);\n        }\n    }\n\n    /**\n     * Servo Execute\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\n    */\n    //% blockId=magicbit_servo block=\"Servo|%index|degree %degree\"\n    //% weight=100\n    //% degree.min=0 degree.max=180\n    export function Servo(index: Servos, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\n        let value = v_us * 4096 / 20000\n        setPwm(index + 7, 0, value)\n    }\n\n    /**\n      * Servo Execute (from-to)\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\n      * @param degree1 [0-180] degree of servo; eg: 0, 90, 180\n      * @param degree2 [0-180] degree of servo; eg: 0, 90, 180\n      * @param speed [1-10] speed of servo; eg: 1, 10\n     */\n    //% blockId=motorbit_servospeed block=\"Servo|%index|degree start %degree1|end %degree2|speed %speed\"\n    //% weight=98\n    //% degree1.min=0 degree1.max=180\n    //% degree2.min=0 degree2.max=180\n    //% speed.min=1 speed.max=10\n    //% inlineInputMode=inline\n    export function Servospeed(index: Servos, degree1: number, degree2: number, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        if (degree1 > degree2) {\n            for (let i = degree1; i > degree2; i--) {\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\n                let value = v_us * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n        else {\n            for (let i = degree1; i < degree2; i++) {\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\n                let value = v_us * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n    }\n\n    /**\n     * Geek Servo Execute\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\n     * @param pwm pulse width [500-2500] in ms of servo; eg: 500, 1500, 2500\n    */\n    //% blockId=magicbit_geekservo block=\"Servo|%index|pulse width %v_us\"\n    //% weight=90\n    //% v_us.min=300 v_us.max=2800\n    export function GeekServo(index: Servos, v_us: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        // 50hz: 20,000 us\n        let value = Math.constrain(v_us, 300, 2800) * 4096 / 20000\n        setPwm(index + 7, 0, value)\n    }\n\n    /**\n      * Geek Servo Execute (from-to)\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\n      * @param pwm1 [300-2800];\n      * @param pwm2 [300-2800];\n      * @param speed [1-10] speed of servo; eg: 1, 10\n     */\n    //% blockId=motorbit_gsrvspeed block=\"Servo|%index|pulse start %pwm1|end %pwm2|speed %speed\"\n    //% weight=87\n    //% pwm1.min=400 pwm1.max=2600\n    //% pwm2.min=400 pwm2.max=2600\n    //% speed.min=1 speed.max=10\n    //% inlineInputMode=inline\n    export function GeekServospeed(index: Servos, pwm1: number, pwm2: number, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        pwm1 = Math.round(pwm1 / 10) * 10\n        pwm2 = Math.round(pwm2 / 10) * 10\n        // 50hz: 20,000 us\n        if (pwm1 > pwm2) {\n            for (let i = pwm1; i >= pwm2; i -= 10) {\n                let value = i * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n        else {\n            for (let i = pwm1; i <= pwm2; i += 10) {\n                let value = i * 4096 / 20000\n                basic.pause(4 * (10 - speed));\n                setPwm(index + 7, 0, value)\n            }\n        }\n    }\n\n    /**\n     * Release servo\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\n    */\n    //% blockId=magicbit_stopservo block=\"Servo|%index|\"\n    //% weight=80\n    export function StopServo(index: Servos): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setPwm(index + 7, 0, 0)\n    }\n}"}]},{"timestamp":1744234336692,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":380,"start2":380,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// Tady jsou testy. Při použití tohoto balíčku jako rozšíření nebude zkompilováno.\n"}]}],"snapshots":[{"timestamp":1744230357144,"editorVersion":"7.0.61","text":{"main.blocks":"","main.ts":"//% color=\"#EE6A50\" icon=\"\\uf013\" block=\"Magic:bit PCAmotor\" blockId=\"PCAmotor\"\r\nnamespace PCAmotor {\r\n    const PCA9685_ADDRESS = 0x40\r\n    const MODE1 = 0x00\r\n    const MODE2 = 0x01\r\n    const SUBADR1 = 0x02\r\n    const SUBADR2 = 0x03\r\n    const SUBADR3 = 0x04\r\n    const PRESCALE = 0xFE\r\n    const LED0_ON_L = 0x06\r\n    const LED0_ON_H = 0x07\r\n    const LED0_OFF_L = 0x08\r\n    const LED0_OFF_H = 0x09\r\n    const ALL_LED_ON_L = 0xFA\r\n    const ALL_LED_ON_H = 0xFB\r\n    const ALL_LED_OFF_L = 0xFC\r\n    const ALL_LED_OFF_H = 0xFD\r\n\r\n    const STP_CHA_L = 2047\r\n    const STP_CHA_H = 4095\r\n\r\n    const STP_CHB_L = 1\r\n    const STP_CHB_H = 2047\r\n\r\n    const STP_CHC_L = 1023\r\n    const STP_CHC_H = 3071\r\n\r\n    const STP_CHD_L = 3071\r\n    const STP_CHD_H = 1023\r\n\r\n    export enum Motors {\r\n        //% block=\"M1\"\r\n        M1 = 0x3,\r\n        //% block=\"M2\"\r\n        M2 = 0x4,\r\n        //% block=\"M3\"\r\n        M3 = 0x1,\r\n        //% block=\"M4\"\r\n        M4 = 0x2\r\n    }\r\n\r\n    export enum Steppers {\r\n        //% block=\"STPM1\"\r\n        STPM1 = 0x1,\r\n        //% block=\"STPM2\"\r\n        STPM2 = 0x2\r\n    }\r\n\r\n    export enum Servos {\r\n        //% block=\"S1\"\r\n        S1 = 0x01,\r\n        //% block=\"S2\"\r\n        S2 = 0x02,\r\n        //% block=\"S3\"\r\n        S3 = 0x03,\r\n        //% block=\"S4\"\r\n        S4 = 0x04,\r\n        //% block=\"S5\"\r\n        S5 = 0x05,\r\n        //% block=\"S6\"\r\n        S6 = 0x06,\r\n        //% block=\"S7\"\r\n        S7 = 0x07,\r\n        //% block=\"S8\"\r\n        S8 = 0x08\r\n    }\r\n\r\n    let initialized = false\r\n\r\n    function i2cwrite(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2ccmd(addr: number, value: number) {\r\n        let buf = pins.createBuffer(1)\r\n        buf[0] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    function initPCA9685(): void {\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\r\n        setFreq(50);\r\n        for (let idx = 0; idx < 16; idx++) {\r\n            setPwm(idx, 0, 0);\r\n        }\r\n        initialized = true\r\n    }\r\n\r\n    function setFreq(freq: number): void {\r\n        // Constrain the frequency\r\n        let prescaleval = 25000000;\r\n        prescaleval /= 4096;\r\n        prescaleval /= freq;\r\n        prescaleval -= 1;\r\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\r\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\r\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\r\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\r\n        control.waitMicros(5000);\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\r\n    }\r\n\r\n    function setPwm(channel: number, on: number, off: number): void {\r\n        if (channel < 0 || channel > 15)\r\n            return;\r\n        //serial.writeValue(\"ch\", channel)\r\n        //serial.writeValue(\"on\", on)\r\n        //serial.writeValue(\"off\", off)\r\n\r\n        let buf = pins.createBuffer(5);\r\n        buf[0] = LED0_ON_L + 4 * channel;\r\n        buf[1] = on & 0xff;\r\n        buf[2] = (on >> 8) & 0xff;\r\n        buf[3] = off & 0xff;\r\n        buf[4] = (off >> 8) & 0xff;\r\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\r\n    }\r\n\r\n    function setStepper(index: number, dir: boolean): void {\r\n        if (index == 1) {\r\n            if (dir) {\r\n                setPwm(0, STP_CHA_L, STP_CHA_H);\r\n                setPwm(2, STP_CHB_L, STP_CHB_H);\r\n                setPwm(1, STP_CHC_L, STP_CHC_H);\r\n                setPwm(3, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(3, STP_CHA_L, STP_CHA_H);\r\n                setPwm(1, STP_CHB_L, STP_CHB_H);\r\n                setPwm(2, STP_CHC_L, STP_CHC_H);\r\n                setPwm(0, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        } else {\r\n            if (dir) {\r\n                setPwm(4, STP_CHA_L, STP_CHA_H);\r\n                setPwm(6, STP_CHB_L, STP_CHB_H);\r\n                setPwm(5, STP_CHC_L, STP_CHC_H);\r\n                setPwm(7, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(7, STP_CHA_L, STP_CHA_H);\r\n                setPwm(5, STP_CHB_L, STP_CHB_H);\r\n                setPwm(6, STP_CHC_L, STP_CHC_H);\r\n                setPwm(4, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        }\r\n    }\r\n\r\n    function stopMotor(index: number) {\r\n        setPwm((index - 1) * 2, 0, 0);\r\n        setPwm((index - 1) * 2 + 1, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Stepper run\r\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\r\n     * @param dir is forward direction; eg: true\r\n    */\r\n    //% blockId=magicbit_stepper_start block=\"Stepper 28BYJ-48|%index|start\"\r\n    //% weight=92\r\n    export function StepperStart(index: Steppers, dir: boolean = true): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(index, dir);\r\n    }\r\n\r\n    /**\r\n     * Stepper stop\r\n     * @param index Stepper; eg: PCAmotor.Steppers.STPM1\r\n    */\r\n    //% blockId=magicbit_stepper_stop block=\"Stepper 28BYJ-48|%index|stop\"\r\n    //% weight=93\r\n    export function StepperStop(index: Steppers): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        for (let i = 4; i > 0; i--) {\r\n            setPwm(index * 4 - i, 0, 0);\r\n        }\r\n    }\r\n\r\n    //% blockId=magicbit_stepper_degree block=\"Stepper 28BYJ-48|%index|degree %degree\"\r\n    //% weight=90\r\n    export function StepperDegree(index: Steppers, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(index, degree > 0);\r\n        degree = Math.abs(degree);\r\n        basic.pause(10240 * degree / 360);\r\n        //StopMotor\r\n        for (let i = 3; i <= 0; i--) {\r\n            setPwm(index * 4 - i, 0, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stepper Car move forward\r\n     * @param distance Distance to move in cm; eg: 10, 20\r\n     * @param diameter diameter of wheel in mm; eg: 48\r\n    */\r\n    //% blockId=magicbit_stpcar_move block=\"Car Forward|Distance(cm) %distance|Wheel Diameter(mm) %diameter\"\r\n    //% weight=88\r\n    export function StpCarMove(distance: number, diameter: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        let delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\r\n        setStepper(1, delay > 0);\r\n        setStepper(2, delay > 0);\r\n        delay = Math.abs(delay);\r\n        basic.pause(delay);\r\n        MotorStopAll()\r\n    }\r\n\r\n    /**\r\n     * DC motor run\r\n     * @param index Index of motor; eg: PCAmotor.Motors.M1\r\n     * @param speed relative speed from -255 to 255; eg: 200\r\n    */\r\n    //% blockId=magicbit_motor_run block=\"Motor|%index|speed %speed\"\r\n    //% weight=85\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRun(index: Motors, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        speed = speed * 16; // map 255 to 4096\r\n        if (speed >= 4096) {\r\n            speed = 4095\r\n        }\r\n        if (speed <= -4096) {\r\n            speed = -4095\r\n        }\r\n        if (index > 4 || index <= 0)\r\n            return\r\n        let pp = (index - 1) * 2\r\n        let pn = (index - 1) * 2 + 1\r\n        if (speed >= 0) {\r\n            setPwm(pp, 0, speed)\r\n            setPwm(pn, 0, 0)\r\n        } else {\r\n            setPwm(pp, 0, 0)\r\n            setPwm(pn, 0, -speed)\r\n        }\r\n    }\r\n\r\n    //% blockId=magicbit_stop block=\"Motor Stop|%index|\"\r\n    //% weight=80\r\n    export function MotorStop(index: Motors): void {\r\n        MotorRun(index, 0);\r\n    }\r\n\r\n    //% blockId=magicbit_stop_all block=\"Motor Stop All\"\r\n    //% weight=79\r\n    //% blockGap=50\r\n    export function MotorStopAll(): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        for (let idx = 1; idx <= 4; idx++) {\r\n            stopMotor(idx);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Servo Execute\r\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\r\n    */\r\n    //% blockId=magicbit_servo block=\"Servo|%index|degree %degree\"\r\n    //% weight=100\r\n    //% degree.min=0 degree.max=180\r\n    export function Servo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n\r\n    /**\r\n      * Servo Execute (from-to)\r\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n      * @param degree1 [0-180] degree of servo; eg: 0, 90, 180\r\n      * @param degree2 [0-180] degree of servo; eg: 0, 90, 180\r\n      * @param speed [1-10] speed of servo; eg: 1, 10\r\n     */\r\n    //% blockId=motorbit_servospeed block=\"Servo|%index|degree start %degree1|end %degree2|speed %speed\"\r\n    //% weight=98\r\n    //% degree1.min=0 degree1.max=180\r\n    //% degree2.min=0 degree2.max=180\r\n    //% speed.min=1 speed.max=10\r\n    //% inlineInputMode=inline\r\n    export function Servospeed(index: Servos, degree1: number, degree2: number, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        if (degree1 > degree2) {\r\n            for (let i = degree1; i > degree2; i--) {\r\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n                let value = v_us * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }\r\n        }\r\n        else {\r\n            for (let i = degree1; i < degree2; i++) {\r\n                let v_us = (i * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n                let value = v_us * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Geek Servo Execute\r\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n     * @param pwm pulse width [500-2500] in ms of servo; eg: 500, 1500, 2500\r\n    */\r\n    //% blockId=magicbit_geekservo block=\"Servo|%index|pulse width %v_us\"\r\n    //% weight=90\r\n    //% v_us.min=300 v_us.max=2800\r\n    export function GeekServo(index: Servos, v_us: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let value = Math.constrain(v_us, 300, 2800) * 4096 / 20000\r\n        setPwm(index + 7, 0, value)\r\n    }\r\n\r\n    /**\r\n      * Geek Servo Execute (from-to)\r\n      * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n      * @param pwm1 [300-2800];\r\n      * @param pwm2 [300-2800];\r\n      * @param speed [1-10] speed of servo; eg: 1, 10\r\n     */\r\n    //% blockId=motorbit_gsrvspeed block=\"Servo|%index|pulse start %pwm1|end %pwm2|speed %speed\"\r\n    //% weight=87\r\n    //% pwm1.min=400 pwm1.max=2600\r\n    //% pwm2.min=400 pwm2.max=2600\r\n    //% speed.min=1 speed.max=10\r\n    //% inlineInputMode=inline\r\n    export function GeekServospeed(index: Servos, pwm1: number, pwm2: number, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        pwm1 = Math.round(pwm1 / 10) * 10\r\n        pwm2 = Math.round(pwm2 / 10) * 10\r\n        // 50hz: 20,000 us\r\n        if (pwm1 > pwm2) {\r\n            for (let i = pwm1; i >= pwm2; i -= 10) {\r\n                let value = i * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }\r\n        }\r\n        else {\r\n            for (let i = pwm1; i <= pwm2; i += 10) {\r\n                let value = i * 4096 / 20000\r\n                basic.pause(4 * (10 - speed));\r\n                setPwm(index + 7, 0, value)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release servo\r\n     * @param index Servo Channel; eg: PCAmotor.Servos.S1\r\n    */\r\n    //% blockId=magicbit_stopservo block=\"Servo|%index|\"\r\n    //% weight=80\r\n    export function StopServo(index: Servos): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setPwm(index + 7, 0, 0)\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"motors\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1744234336692,"editorVersion":"7.0.61","text":{"main.blocks":"","main.ts":"function drawTurtle(cmds: number[][]) {\r\n    bluetooth.uartWriteString(\"%dsta\")\r\n    console.log(\"drawing\" + cmds)\r\n    for (let i = 0; i < cmds.length; i++) {\r\n        bluetooth.uartWriteString(\"%dr\" + i)\r\n        console.log(cmds[i])\r\n        if (cmds[i][0] == 1) {\r\n            //forwards\r\n            vanGogh.fd(cmds[i][1])\r\n        } else if (cmds[i][0] == 2) {\r\n            //left\r\n            vanGogh.re(cmds[i][1], false)\r\n        } else if (cmds[i][0] == 3) {\r\n            //right\r\n            vanGogh.re(cmds[i][1], true)\r\n        } else if (cmds[i][0] == 4) {\r\n            vanGogh.penDown()\r\n        } else if (cmds[i][0] == 5) {\r\n            //penup\r\n            vanGogh.penUp()\r\n        }\r\n    }\r\n    vanGogh.penUp()\r\n    bluetooth.uartWriteString(\"%dend\")\r\n}\r\nlet cmds: number[][] = [[3]]\r\nvanGogh.penDown()\r\nvanGogh.penUp()\r\nbluetooth.startUartService();\r\nconsole.log(\"started\");\r\n\r\n\r\nfunction stringToNumberMatrix(input: string): number[][] {\r\n    const matrix: number[][] = [];\r\n    // Split the string by the substring \"],[\"\r\n    const rows = input.split(\"],[\");\r\n    for (let row of rows) {\r\n        row = row.trim();\r\n        // Remove any leading '[' from the first chunk\r\n        if (row[0] === \"[\") {\r\n            row = row.slice(1, row.length);\r\n        }\r\n        // Remove any trailing ']' from the last chunk\r\n        if (row[row.length - 1] === \"]\") {\r\n            row = row.slice(0, row.length - 1);\r\n        }\r\n        // Split by comma and convert to numbers\r\n        const numbers = row\r\n            .split(\",\")\r\n            .map((value) => parseFloat(value.trim()))\r\n            .filter((num) => !isNaN(num));\r\n        matrix.push(numbers);\r\n    }\r\n    return matrix;\r\n}\r\n\r\nlet receivedData = \"\";\r\n\r\nbluetooth.onUartDataReceived(serial.delimiters(Delimiters.NewLine), function () {\r\n    const received = bluetooth.uartReadUntil(serial.delimiters(Delimiters.NewLine));\r\n    //console.log(\"Received: \" + received);\r\n    if (received === \"#\") {\r\n        console.log(\"received all data\");\r\n        cmds = stringToNumberMatrix(receivedData);\r\n        drawTurtle(cmds);\r\n        receivedData = \"\";\r\n    } else {\r\n        receivedData += received;\r\n    }\r\n})\r\n\r\nbluetooth.onBluetoothConnected(function () {\r\n    music.playTone(Note.A4, 100)\r\n})\r\nbluetooth.onBluetoothDisconnected(function () {\r\n    music.playTone(Note.C3, 100)\r\n})","README.md":"","vangogh.ts":"//% color=\"#CC7722\" icon=\"/f1fc\" block=\"Van Gogh\" blockId=\"vanGogh\"\nnamespace vanGogh {\n    // initialization of servos\n    const _pen = PCAmotor.Servos.S1;\n    const _left = PCAmotor.Steppers.STPM1;\n    const _right = PCAmotor.Steppers.STPM2;\n    // How much does the pen lower or raise\n    const _minPenHeight = 1900;\n    const _maxPenHeight = 1260;\n    //shift speed in mm/ms\n    const _spd = 0.0215;\n    //rotation speed deg/ms\n    const _degSpd = 0.0178;\n\n    // Always start calibration with Distance Calibration then Rotation Calibration\n\n    //% blockId=calibDist block=\"Calibrate distance\"\n    //% weight=79\n    //% blockGap=50\n    export function calibDist() {\n        penUp();\n        basic.pause(500);\n        PCAmotor.StepperStart(_left);\n        PCAmotor.StepperStart(_right);\n        basic.pause(500);\n        PCAmotor.MotorStopAll();\n        penDown();\n        basic.pause(500);\n        PCAmotor.StepperStart(_left);\n        PCAmotor.StepperStart(_right);\n        basic.pause(5000);\n        PCAmotor.MotorStopAll();\n        penUp();\n    }\n\n    //% blockId=calibRot block=\"Calibrate rotation\"\n    //% weight=79\n    //% blockGap=50\n    export function calibRot() {\n        penDown();\n        fd(50);\n        penUp();\n        fd(50, false);\n        penDown();\n        PCAmotor.StepperStart(_left, false);\n        PCAmotor.StepperStart(_right);\n        basic.pause(5000);\n        PCAmotor.MotorStopAll();\n        fd(50);\n        penUp();\n        fd(50, false);\n    }\n\n    /**\n     * Van Gogh move\n     * @param dist is distance of run in mm; eg: 10\n     * @param invert is direction forward or backward; eg: true\n    */\n    //% blockId=fd block=\"Van Gogh move |%dist| mm forward |%invert|\"\n    //% weight=92\n    export function fd(dist: number, invert: boolean = true): void {\n        PCAmotor.StepperStart(_left, invert);\n        PCAmotor.StepperStart(_right, invert);\n        basic.pause(calcDist(dist));\n        PCAmotor.MotorStopAll();\n    }\n\n    /**\n     * Van Gogh move with certain speed\n     * @param dist is distance of run in mm; eg: 10\n     * @param interval is indicates the frequency of stopping in ms; eg: 10\n     * @param invert is direction forward or backward; eg: true\n    */\n    //% blockId=fdSpeed block=\"Van Gogh move |%dist| mm forward |%invert| with stopping |%interval|\"\n    //% weight=92\n    export function fdSpeed(dist: number, invert: boolean = true, interval: number = 1000): void {\n        for (let i = 0; i <= interval; i++) {\n            fd(dist / interval, invert);\n            PCAmotor.MotorStopAll();\n            basic.pause(1);\n        }\n    }\n\n    /**\n     * Van Gogh rotate\n     * @param deg is rotation in degrees; eg: 10\n     * @param invert is direction of rotation; eg: true\n    */\n    //% blockId=re block=\"Van Gogh rotate |%deg|° clockwise |%invert|\"\n    //% weight=92\n    export function re(deg: number, invert: boolean = true): void {\n        PCAmotor.StepperStart(_left, invert);\n        PCAmotor.StepperStart(_right, !invert);\n        basic.pause(calcDeg(deg));\n        PCAmotor.MotorStopAll();\n    }\n\n    // Calculate distance to time with calibrated run speed\n    function calcDist(t: number): number {\n        return t / _spd;\n    }\n    // VCalculate rotation to time with calibrated rotation speed\n    function calcDeg(d: number): number {\n        return d / _degSpd;\n    }\n\n    //% blockId=penUp block=\"Raise pen\"\n    //% weight=79\n    //% blockGap=50\n    export function penUp(): void {\n        PCAmotor.GeekServo(_pen, _minPenHeight);\n        basic.showArrow(ArrowNames.North);\n    }\n\n    //% blockId=penDown block=\"Launch pen\"\n    //% weight=79\n    //% blockGap=50\n    export function penDown(): void {\n        PCAmotor.GeekServo(_pen, _maxPenHeight);\n        basic.showArrow(ArrowNames.South);\n    }\n\n    /**\n     * Van Gogh draw rectangle\n     * @param a is length of side A; eg: 10\n     * @param b is length of side B; eg: 10\n    */\n    //% blockId=rectangle block=\"Van Gogh draw rectangle of size |%a| mm side A and of size |%b| mm side B\"\n    //% weight=92\n    export function rectangle(a: number, b: number): void {\n        penDown();\n        for (let i = 0; i < 4; i++) {\n            re(90);\n            fd(i % 2 == 0 ? a : b);\n        }\n        penUp();\n    }\n\n    /**\n     * Van Gogh draw circle\n     * @param d is diameter of circle; eg: 10\n    */\n    //% blockId=circle block=\"Van Gogh draw circle with diameter of |%d| mm\"\n    //% weight=92\n    export function circle(d: number): void {\n        const circumference = Math.PI * d;\n        penUp();\n        fd(d / 2);\n        re(90);\n        for (let i = 0; i < 60; i++) {\n            penDown();\n            fd(circumference / 60);\n            re(6);\n        }\n        penUp();\n    }\n}","pxt.json":"{\n    \"name\": \"pxt-vangogh-painter\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"bluetooth\": \"*\",\n        \"pxt-magicbit-pca9685\": \"github:microbit-cz/pxt-magicbit-pca9685#1e097c914b2c7ed1f4071d7b6288ef64812030e2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"vangogh.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"yotta\": {\n        \"config\": {\n            \"microbit-dal\": {\n                \"bluetooth\": {\n                    \"open\": 1,\n                    \"whitelist\": 0,\n                    \"security_level\": null\n                }\n            }\n        }\n    }\n}\n"}}],"shares":[{"id":"72273-77396-13914-27861","timestamp":1744234304014}],"lastSaveTime":1744234336698}